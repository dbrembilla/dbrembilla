<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Questions</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
    <script src='main.js'></script>
</head>
<body>
    <div style='max-width:1000px;word-wrap: break-word;'>
    <p>Domande OC:</p>
    <details>
        <summary>
            23 febbraio
        </summary>
        <div class="content">
            <p>
                <ul>
                    <li>Come funziona l'attribuzione dei ruoli nell'OCDM? In che modo si conserva il ruolo dell'agente nel contesto?</li>
                    <li>A cosa serve ArgumentParser?</li>
                </ul>
            </p>
        </div>
    </details>
    <details>
        <summary>
            2 marzo
        </summary>
        <div class="content">
            <ul>
                <li>
                    Tra gli identifiermanagers, ci sar√† anche il MetaID Manager?
                </li>
                <li>
                    Come funziona l'attribuzione dei ruoli nell'OCDM?
                </li>
            </ul>
            
        </div>
    </details>
    <details>
        <summary>
            <p>9 marzo</p>
        </summary>
        <div class="content">
                <li><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAesAAAFzCAYAAAAexiGPAAAG0HRFWHRteGZpbGUAJTNDbXhmaWxlJTIwaG9zdCUzRCUyMmFwcC5kaWFncmFtcy5uZXQlMjIlMjBtb2RpZmllZCUzRCUyMjIwMjItMDMtMDRUMTAlM0E1NCUzQTM4LjU1MlolMjIlMjBhZ2VudCUzRCUyMjUuMCUyMChXaW5kb3dzKSUyMiUyMGV0YWclM0QlMjJXV09xdGpsMXBnZXNHTGREWW1rNiUyMiUyMHZlcnNpb24lM0QlMjIxNi42LjUlMjIlMjB0eXBlJTNEJTIyZGV2aWNlJTIyJTNFJTNDZGlhZ3JhbSUyMGlkJTNEJTIyeTg3bzRmMGU5d1ZRRnBKeEVaUUslMjIlMjBuYW1lJTNEJTIyUGFnZS0xJTIyJTNFM1ZuZmQ1b3dGUDVyZkZ3UEVLdjJzV3E3N2F4YmQ5YnRySHVNY0pXMFFGZ0lWZmJYN3dZU0VLUE9udGJTN2tYSVIzNSUyQjk3czNON0ZISnZIcXZhQnAlMkJKa0hFUFU4SjFqMXlMVG5lYTVEUnZoUVNGRWhwMlJRQVF2QkFsMnBBVzdZSHpBdE5acXpBTEpXUmNsNUpGbmFCbjJlSk9ETEZrYUY0TXQydFRtUDJxT21kQUVXY09QVHlFWiUyRnNrQ0dGVHJ5aGczJTJCQWRnaU5DTzdnN1BxUzB4TlpiMlNMS1FCWDY1QjVLSkhKb0p6V2IzRnF3bEVpanpEUzlYdWNzZlhlbUlDRW5sSUElMkYlMkJhVE1uWVdYNmR4dmYzWHp4SlBxM3UzbWxqUE5BbzF3dldrNVdGWVFBQ0pFUVh1WkFoWCUyRkNFUmhjTk9oWThUd0pRd3poWWF1cGNjWjRpNkNKNEIxSVcycm8wbHh5aFVNYVIlMkZscU5xUWJhdVRZTlpUd1hQdXhaa05FSUZRdVFlJTJCcjFhd3VnZElISElFV0I3UVJFVkxLSDlqeW8xdENpcnRmUWpDJTJCYTZVZXc3bHFzJTJGOGhBS0xYajBKbHFuY3k1UUFVeG5xanhaenlYNnFsMHpxU0JtZnFaZkx1ZWZMUnMxcmJJTW1RU2JsSmFFcmRFUDkzRyUyRmdNSUNhdjklMkZOdDg2UVo5cmZIQ09LOHVMeHVYY1kwZmhHdnVNbkNPeERENTMzVHRIYWpySFhaNkdWMTdGdXMzT0dGcFV4OUZHTCUyRmhSYVE1YkV1emJ5dHpzRVdZJTJGV01KYzJSUkZIRDJ4clhaUDFDYnd5ZHFzMng2TGdRdDFpcWtuQ1V5VyUyQnY1cXdJYSUyQjlleFNBdUF1QnZiNU9QcTQwczFnMFlDOVZLZXNDR1FMaVFBS3ladjE5NSUyRnFhNU9UblZwdXRJOWw0WENGQkpjNlcxVFVSViUyRm1UNVVvV2xXbGt5N0R1VG1kaG9MM2FIbDZRbXZHbTB6OVJXZFllYmNNZyUyQk4yQ0xCZHg4Wnd1eUFqRlVjWkppYW51c1BNUXVDU2dtUXNUOTBWdmFueU5ZJTJCZ1oyZmpudW4wMzJCVk9mTnVuR3Z6bGJYRGJOSHNqdkRybk15N0xjRGIxVjZuTE0zM21tcThQazhBMmxaNXpsOHNQOVdmUEM1ZmVtcElkbUtvZldXYW1MbzVuWmElMkJhNXVkUVJUMnNjYTdKTCUyQk42NjN3MnExNncyOElYbGJ6dGUzRFBhOVNBRVJQaTlQT2lrZWdNaWxaVDRSOG5pV1p5JTJCU1NHNW8ydHR5eGhsdHlTUkh4OG9rN2YzRkQ4RyUyRlI2ak1LSlc4TXBaSlNId2NhN0o1cUZSQWl1TEZ6MkRPa3NwSGJJcTdQVXFTTFFuN0N4OGxIWXZvTGphS1p3ejY3cUdYSk41WnB4bVVmVTN5UFlSQ1g1T1VDNDNMRUNIRDh2SkV5VGVnU3NMMWpRbFRQNTFMMm5OZTIlMkZXSVp4OURUZkF3RzZVZFB6YkR4ZWN5WERnZyUyRlpOWFIlMkZFckNCdjJaY2diRHh2ZTJZRmhnM1I3Q1hWbUVYJTJCZVpTcHRxMjVRSmNRcEY3U2NrZXBvckxTdXhZOGJwS29Sd3VaMnVhNzREU1AlMkJROXh0Q3o3TEJ2bmFvZ214QTNYUEcwUTQ3SGpPeXdUUzV4RXlxNzRNZnVmcUR3OGtnbHhlT282YWV3TU5GdW81emxrVWFHTmx2bUNwNmdGWjlrTjglMkZzNUJzUEtPZktlVnJpZG05Smt3ZlJvRTExZE55Y0NkWnpzYldhVjNQR05pc2ZtM3FVcmNtJTJGJTJGc3lNVmYlM0MlMkZkaWFncmFtJTNFJTNDJTJGbXhmaWxlJTNF+U1nUwAAIABJREFUeF7tnQ2wVsWZ5xuNCCqoqBcxmLKGLYtkEhgwxIR1srtDzcIGSGKyxEA2ioGNVUHKm9lZIy4EESLEqRgsdFMTQZNoYEcrHxtlF2rK7M6Mq5WgUPfGJGxqmbLiFxdjVPAjYJTt51yea9++3ef0+e7u83+rjnLf95zup//9dP/O06f79CiBDxSAAlAACkABKOC1AqO8tg7GQQEoAAWgABSAAgKwhhNAASgABaAAFPBcAcDa8wqCeVAACkABKAAFAGv4ABSAAlAACkABzxXoAqypjJfI44OnnXbapaecckrPSSeddI48zj169OgZx44do+P00aNHvzZmzJjXR40a9ZL89xH53cArr7zyjLxunzyekMfj8jjueX3CPCgABaAAFIhQgRhhfZKspyvOOOOMfyPB/C8lcKdeeOGFL1966aXHTz755HM++clPirPPPnvYcdZZZ4mXX35ZvPTSS8OOH//4x0JC/dXHHnvsraeeemrcmWeeuV+e81OZ/qPy+Dt5vB2hT6BIUAAKQAEo4JkCMcH6L8eOHfv5P/7xj5+ZPXv20Y997GOnfPjDHx57ySWXiNNPP7207K+99pp44oknxOOPPy5++MMfvvjzn//8jDfffPNemfD98vj70hkgASgABaAAFIACFgVCh/Xp48ePv1lCc/F73vOeMVdfffWYJUuWjJWRdO0V/vTTT4v7779f3HXXXS8999xzfzxy5MhdMtNb5PFa7ZkjAygABaAAFOiUAiHD+jo5zH3T4sWLT+7t7R03Y8aM1ipu37594o477ji2ffv2o3/4wx/WSENub80YZAwFoAAUgALRKRAirBePGzfuFvkM+uxbbrnlzFmzZnlTKXv27BE33njjK3v37n3197///X+Whu3wxjgYAgWgABSAAsEqEBSs5TPp71100UXzb7311gkLFizwVvSHHnpIrFq16vCBAwf++xtvvHGlt4bCMCgABaAAFAhCgVBg/Sfy2fQDCxcuvPi+++47IwhlpZFLly499qMf/ejJw4cPL5J//nModsNOKAAFoAAU8EuBEGA979RTT/1vX/3qV0fLIeaxfsmXbY0cBRDr1q179fXXXydg78q+AmdAASgABaAAFBiugO+w/nP5kpL/LZdKnUTro0P90HrtT33qU28fP378X8sy/FOo5YDdUAAKQAEo0I4CPsN6kpxI1idnWZ9+5ZVXntaOPNXl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" style="cursor:pointer;max-width:100%;" onclick="(function(img){if(img.wnd!=null&&!img.wnd.closed){img.wnd.focus();}else{var r=function(evt){if(evt.data=='ready'&&evt.source==img.wnd){img.wnd.postMessage(decodeURIComponent(img.getAttribute('src')),'*');window.removeEventListener('message',r);}};window.addEventListener('message',r);img.wnd=window.open('https://viewer.diagrams.net/?client=1&page=0&edit=_blank');}})(this);"/>
      </li>
        <li>Sto pensando al procedimento che dovr√† esserci all'interno di Croci, e mi sono fermato qui. Non mi √® chiaro se negli script c'√® gi√† qualcosa che faccia query basate sugli altri metadati.</li>
        </div>
    </details>
    <details>
        <summary>
            <p>22 marzo</p>
        </summary>
        <div class="content">
            <ul>
                <li>In questi giorni ho fatto un po' di test su cnc.py per croci, per vedere esattamente come va. Ho fatto un fork dell'index per modificare i diversi script.</li>
                <li>Mi sono bloccato perch√© sto avendo problemi con l'header di un mock csv che sto usando per fare i miei test. Non capisco se c'√® un errore nel modo in cui ho impostato il csv.</li>
                <li>Legge le chiavi del DictReader come <pre>"doi:10.1234/test","i"</pre></li>
                <li><a href='to_test.csv'> Qui c'√® il csv che sto testando</a></li>
                <li>Il comando che sto usando √® </li>
                <code>python cnc.py -c croci -i "mockup_data/to_test.csv" -d "given_data" -l "index/test_data/lookup_full.csv" -b "https://w3id.org/oc/index/croci/" -ib "http://dx.doi.org/" -doi "invalid_doi/data.csv" -s "https://example.org/" -v -a "https://w3id.org/oc/index/prov/pa/1" -sv "https://example.org/"</code>
                </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>29 marzo</p>
        </summary>
        <div class="content">
            <ul>
                <li>Sto iniziando a creare le funzioni per validare un MetaID, per ora inviare richieste ma lavorando solo per verificare che riconosca se a Croci arriva un DOI o un MetaID. Per ora far√≤ solo in locale lavorando sulla stringa, in futuro vorrei aggiungere anche via API un controllo se questo esiste. <b>Ci vuole un validate, che sar√† una query ask su meta. se √® cancellato, trova quello nuovo. Funzione esiste gi√†: idmanager restituisce in output il metaid della risorsa, o il metaid stesso se √® riconosciuto come valido. </b> </li>
                <li>Volevo chiedere, per gestire questa molteplicit√†, immagino dovr√≤ cambiare le funzioni su pi√π livelli. Croci dovr√† funzionare a contatto con Meta per pescare gli articoli gi√† presenti, quindi:
                    <ol>
                        <li>Se MetaID-to-MetaID, valida i MetaID; se non ci sono, invalida la citazione.</li>
                        <li>Se DOI-to-DOI, fa quello che fa ora + verifica su Meta per arricchire di informazioni</li>
                        <li>Se MetaID-to-DOI o viceversa, controlla su Meta e trasforma in MetaID-to-MetaID</li>
                    </ol>
                    Quindi, stavo riflettendo che crowdsourcecitationsource, che ora come ora va a lavorare direttamente sui DOI, dovr√† probabilmente essere diviso tra una parte doicrowdsourcecitationsource e un metaidcrosourcecitationsource. Non so se ha senso questa cosa. <b>Pi√π identificativi!!!! A fine processo: risorse nuove. Problema: bisogna cacciare a forza le informazioni sulla tabella arricchita. Conflitto tra due DOI e MetaID. </b>
                </li>
                <li>In generale, sto avendo problemi ad importare le funzioni, spesso se lancio qualcosa anche da commandline mi d√† ModuleNotFoundError perch√© non trova l'index. Non sto ben capendo come risolvere questa cosa.<b>vedi .env vscode. Bisogna lanciare con py -m e le dir separate da punti es. py -m index.my_test.01_test_metaid_identifier </b></li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>4 aprile</p>
        </summary>
        <div class="content">
        <ul>
            <li>
                Ora che riesco a far girare i test, ho iniziato a creare il MetaIDManager per validare in locale i MetaID (per ora riferiti solo a bibliographic resources) validi. Per ora non verifica l'esistenza di MetaID; in seguito dovr√† lavorare a fianco di una instance di Creator da Meta e fare il giochino con l'id worker, verificando che l'id esiste in Meta se √® un metaid o recuperandolo/creandolo se √® dato un doi
            </li>
            <li>
                Ho preparato una funzione ausiliaria per gestire pi√π id. Non so se ha senso tenerla distinta dalle altre funzioni per normalizzare gli id.<b>Partiamo dal presupposto che il prefisso √® presente. L'aggiunta potrebbe cvvenire in reprocess. DA IDWORKER: se input =/= output il metaid non esiste.</b>
                <pre><code>
                    from re import match

                    def normalise_multiple_ids(id_list, doi,metaid):
                        normalised_ids=None
                        for id in id_list:
                            if match('10\..+\/.+$',id):
                                # It's a DOI! So, normalise it as a doi. Put it in the normalised citing dict if it's normalisable.
                                # If there are multiple dois, use the first one
                                if not normalised_ids:
                                    id = doi.normalise(id)
                                    normalised_ids= {'doi':id}
                                elif 'doi' not in normalised_citing:
                                    normalised_citing['doi'] = id
                    
                            elif match('^060|^br\/060|meta:br\/060'): <b>Importante: c'√® 06 all'inizio, 0 alla fine NO 0 in mezzo</b>
                                if not normalised_citing:
                                    id = metaid.normalise(id)
                                    normalised_citing = {'metaid':id}
                                elif 'metaid' not in normalised_citing:
                                    normalised_citing['metaid'] = id
                        return normalised_ids
                    </code></pre>
            </li>
            <li>
                Per la parte di Ramose, ho iniziato a guardare gli elementi necessari per caricare su pypi, oltre che ovviamente agli script.<b>Account su pypi per pubblicarci. readthedoc.io</b>
            </li>
        </ul></div>
    </details>
    <details>
        <summary>
            <p>11 aprile</p>
        </summary>
        <div class="content">
            <ul>
                <li>Ho cambiato croci per fare in modo che, a seconda del prefisso, usi l'idmanager corretto. Ho anche corretto per tenere conto del metaid come <code>'^06[1-9]*0$'</code>. Ho anche iniziato a fare i test case (per ora solo per i doi). Intanto, volevo chiedere se c'√® un dump di metaid che posso usare per fare questi test.<
                    b>Senti Arcangelo</b> </li>
                <li>Ho iniziato a guardare poetry e a creare le varie dependencies<b> CROCI parte da file corretto, deve fare un preprocess che ti d√† la tabella metaid to metaid. INPUT per meta: tabella con pub date e id. ouput: campo id + metaid. </b></li>
                <li><a onclick="showthis('toml1');">Ho creato il file .toml per iniziare a testarlo</a><b></b></li>
                <li id="toml1"><pre><code>
                    [tool.poetry]
                    name = "ramose"
                    version = "0.0.2"
                    description = "Restful API Manager Over SPARQL Endpoints (RAMOSE) is an application that allows agile development and publication of documented RESTful APIs for querying SPARQL endpoints, according to a particular specification document."
                    authors = ["essepuntato <essepuntato@gmail.com>"]
                    license = "ISC"
                    repository = "https://github.com/opencitations/ramose/"

                    [tool.poetry.dependencies]
                    python = "^3.8"
                    certifi = "2019.11.28"
                    chardet = "3.0.4"
                    Click = "7.0"
                    Flask = "1.1.1"
                    idna = "2.8"
                    isodate = "0.6.0"
                    itsdangerous = "1.1.0"
                    Jinja2 = "2.11.3"
                    Markdown = "3.1.1"
                    MarkupSafe = "1.1.1"
                    python-dateutil = "2.8.1"
                    requests = "2.22.0"
                    six = "1.13.0"
                    urllib3 = "1.26.5"
                    Werkzeug = "0.16.0"

                    [tool.poetry.dev-dependencies]

                    [build-system]
                    requires = ["poetry-core>=1.0.0"]
                    build-backend = "poetry.core.masonry.api"

                </code></pre></li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>25 aprile</p>
        </summary>
        <div class="content">
            <ul>
                <li>
                    Per CROCI, su suggerimento di Arcangelo, ne ho ripensato il funzionamento. Al posto di partire da una tabella con id multipli, partir√† con una tabella solo MetaID-to-MetaID. Per fare questo, dovrebbe interfacciarsi con Meta; a questo fine, deve avvenire un preprocess che trasformi la tabella in input compatibile con Meta, in modo da successivamente arricchirla. <b>DA META CI PASSIAMO SOLO CON DOI VALIDI. METADATI: RECUPERA DA SERVIZI ESTERNI. ID ENRICHER. vedi opencitations/oc_graphenricher. copia repo di meta in croci</b>
                    A questo punto, per√≤, si pone il problema di legare il processo di Croci a Meta, quindi all'azione di qualcuno che faccia partire Meta. Quindi:
                    <ol>
                        <li>
                            Potremmo legare l'upload delle citazioni su Croci al primo processo Meta che parte? Avrebbe senso / come si potrebbe fare?
                        </li>
                        <li>
                            Il processo CROCI in origine si occupava della normalizzazione dei DOI. In questo caso, pensavo si potrebbe collegare semplicemente a Meta, che gi√† di questo si occupa. 
                        </li>
                        <li>
                            Per ora non ho inserito uno script che faccia mapping, ma ho fatto un procedimento 'stupido' che assegna i file in ordine row-first in modo da ricollegarsi con questo all'ordine di output e input di meta. In alternativa, potrebbe avere senso usare un pointer che indichi a che riga si trova l'informazione nella tabella di meta. In ogni caso, questi metodi seguono l'assunto che l'output di meta segua l'ordine dell'input. 
                        </li>
                    </ol>
                </li>
                <img src='CROCI Preprocess.png'>
                <li>Un'altra cosa che ho notato che √® da implementare sono le self citations. Anche qui pu√≤ essere d'aiuto Meta.<b>LO FA AUTOMATICAMENTE INDEX; non te ne proccupare. </b></li>
                <li>Rispetto a Ramose, ho provato a collegare ReadTheDocs alla libreria, ma mi d√† degli errori tra i requirements. Sto provando a testarlo in locale cambiando alcune impostazioni, ma devo anche cambiare alcune cose perch√© i test sono pensate non per Windows e quindi mi sta facendo dei capricci.  Per questo ho creato un test_windows.sh per lanciarlo con pi√π facilit√† da Windows.<b>Dopo croci cerca se cit c'√® gi√†</b></li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>2 maggio</p>
        </summary>
        <div class="content">
            <ul>
                <li>Ho iniziato a guardare oc_graphenrcher. Ho provato ad usare le funzioni gi√† presenti per usare le API, ma richiedono alcuni parametri che dalla tabella di CROCI non sarebbero presenti. In particolare, in origine usa: DOI, autori (opzionale) e titolo.
                    Quindi, ho pensato a questo ordine di query:
                    <ol>
                        <li>
                            Crossref/Wikidata: Recupera dati su pubblicazione da DOI/Wikidata. Questa parte richiede una propria funzione.
                        </li>
                        <li>
                            Se cos√¨ facendo √® stato recuperato un autore: popolare con ORCID e VIAF etc.
                        </li>
                    </ol>
                    In questo modo dovrei poter estrarre gli elementi che necessita Meta, cio√® <code>id,title,author,pub_date,venue,volume,issue,page,type,publisher,editor
                    </code>. <br>
                    Su questo codice sto lavorando indirettamente anche per l'esame di Open Science.

                </li>
                <li>
                    Per quanto riguarda Ramose, ho provato a cambiare i requirements mettendo l'ultima versione di requests e sembra non dare pi√π problemi per quanto riguarda la versione. A questo punto volevo chiedere: prima di caricare la library, pu√≤ essere sensato provare se l'ultima versione delle librerie utilizzate funziona? C'√® qualche best practice a riguardo o vado a naso? <b>Pattern matching; confrontati con Giuseppe/Arcangelo. Da PY3.5 a Py3.10</b>
                </li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>9 Maggio</p>
        </summary>
        <div class="content">
            <ul>
                <li>Sto costruendo lo script per popolare il file. Innanzitutto, mi sono accorto che ci sono pi√π titoli su crossref (short title, title, original title). Quali tengo? O posso tenerli tutti per darli a Meta? <b>vedi crossref processing di arcangelo.</b>

                </li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>24 Maggio</p>
        </summary>
        <div class="content">
            <ul>
                <li>Non ho avuto granch√© tempo per lavorare su Croci. Ho applicato il plugin di Meta per gestire l'output di Crossref.
                    <b>problema interno di meta: niente ORCID. Vedi bene anche per i VIAF</b>
                </li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p>31 maggio/6 giugno</p>
        </summary>
        <div class="content">
            <ul>
                <li>Questa settimana ho lavorato sullo script per popolare le righe da poi dare in feed a Meta. per fare questo ho creato uno script che:
                </li>
                <ol>
                    <li>
                        Dato un identificativo in input, lo valida sui servizi dati.
                    </li>
                    <li>
                        Se valido, cerca tra tutti i servizi (per ora  WikiData e Crossref) se esiste una corrispondenza. Se s√¨, ritorna gli identificativi.
                        Lo script √® qui sotto, con il processo decisionale.
                    </li>
                </ol>
                <li>
                    Domande:
                    <ol>
                        <li>
                            Che User Agent uso per wikidata? per ora sto usando abusivamente quello di oc_graphenrcher
                        </li>
                        <li>
                            Dovrei selezionare le entity su Wikidata che sono articoli scientifici e libri, ma Wikidata √® un po' balorda. Devo tenere conto del fatto che l'utente pu√≤ specificare una cosa a caso come identificativo? c'√® anche il problema che scholarly aticles sono segnati come cose a caso (e.g. https://www.wikidata.org/wiki/Q2640 sarebbe un articolo per wikidata). cosa faccio? tengo wikidata solo come lookup? Values che mantengo per ora: wd:Q13442814 (scholarly article) wd:Q571 (book) wd:Q88392887 (part of work) wd:Q1143604 (proceedings) wd:Q7318358 (review article)
                            Una soluzione che mi √® venuta in mente √® di verificare la presenza di altri id per confermarla
                        </li>
                        <li>
                            Dato che CROCI dovr√† essere, in conclusione, any-to-any, potrebbe avere senso utilizzare altri identificativi che WikiData d√† come connessione? (Fatcat, ResearchGate, Publons, arxiv etc.). Tra questi c'√® spesso anche l'OC corpus id; per ora non l'ho inserito.
                        </li>
                    </ol>
                </li>
                <li>
                    Per quanto riguarda Ramose, sto creando i vari test da lanciare con poetry per vedere la coverage. Per ora in realt√† la coverage sembra essere piuttosto bassa. Per ora sto usando la libreria coverage per testare la coverage.
                </li>
                <li>
                    <img src="Meta_Preprocess.drawio.png" alt="meta preprocess" width="100%">
                </li>
                <li>
                    <script src="https://gist.github.com/dbrembilla/1d4abb4c542ebb9e310114d881d31103.js"></script>
                </li>
            </ul>
        </div>
    </details>
    <details>
        <summary>
            <p></p>
        </summary>
        <div class="content">
            <ul>
                <li>
                </li>
            </ul>
        </div>
    </details>
</body>
</html>
